# 밑바닥부터 시작하는 데이터 과학

1. **네트워크 관련**
- **연결 중심성(degree centrality, Cd)**
    
    ![image.png](image.png)
    
    - 중심성 지수에서 가장 간단하면서 기본적인 지표
    - 이웃이 얼마나 많은가(한 Node에 직접적으로 연결된 모든 Edge의 개수)로 지수를 평가
    - 중심성: 그래프에서 꼭짓점이나 노드의 상대적 중요성을 나타내는 척도

1. **파이썬 관련**
- **dict와 defaultdict**
    
    ![image.png](image%201.png)
    
    - dict: 기본적으로 map과 같이 key-value 형태로 데이터를 저장하지만, map과 달리 중복된 key 값이 허용된다.
    - get(), pop(), update(), keys(), items() 메소드 내장
    - {"김연아": "피겨스케이팅", "류현진": "야구", "손흥민": "축구", "귀도": "파이썬"}
    
    ![image.png](image%202.png)
    
    - defaultdict: dictionary와 동일한 형태지만, 모든 key에 대해 기본값을 설정해줌
    - 존재하지 않는 key 값에 접근하게 되면 에러가 발생하는 dict의 문제점을 커버한 자료구조, 일장일단이 있다고 함
        
        <aside>
        💡
        
        ```python
        from collections import defaultdict
        
        # key가 관심사, value가 사용자 id
        user_ids_by_interest = defaultdict(list)
        
        for user_id, interest in interests:
            user_ids_by_interest[interest].append(user_id)
        ```
        
        </aside>
        
    - 책에서는 각 관심사에 대한 사용자 인덱스를 만들 때 선언하여 사용함
- **파이썬의 특징 및 파이썬스러운 코드**
    - 코드의 단락을 구분하는데 중괄호 대신 들여쓰기 사용
    
    ```python
    for i in [1, 2, 3, 4, 5]:
        print(i)
        for j in [1, 2, 3, 4, 5]:
            print(j)
            print(i + j)
        print(i)
    print("done looping")
    ```
    
    - 파이썬 3에서는 실수 나눗셈이 기본 (책은 파이썬2라서 정수 나눗셈이 기본)
    - 함수(0개 혹은 그 이상의 인자를 입력받아 결과를 출력하는 규칙)은 def로 선언
    
    ```python
    def double(x):
        """이 곳은 함수에 대한 설명을 적어 놓는 공간이다.
        예를 들어, "이 함수는 입력된 변수에 2를 곱한 값을 출력해 준다"
        라는 설명을 추가할 수 있다"""
        return x * 2
    ```
    
    - 파이썬 함수는 변수로 할당되거나 함수의 인자로 전달도 가능(first-class/일급 함수의 특징)
    - 짧은 익명의 람다 함수도 생성 가능
    
    ```python
    def apply_to_one(f):
        """인자가 1인 함수 f를 호출"""
        return f(1)
    
    my_double = double                  # 방금 정의한 함수를 나타냄
    x = apply_to_one(my_double)         # 2
    y = apply_to_one(lambda x: x + 4)   # 5
    ```
    
    - 변수에 람다 함수를 할당할 수 있지만, def로 선언하는 게 적절함
    - 함수의 인자에는 기본값 할당 가능
    
    ```python
    def my_print(message="my default message"):
        print(message)
    
    my_print("hello")       # "hello"를 출력
    my_print()              # "my default message"를 출력
    ```
    
    - 역슬래시를 역슬래시로 보이는 문자로 사용하고 싶다면 문자열 앞에 r을 붙임
    
    ```python
    not_tab_string = r"\t"      # 탭(tab)을 의미하는 문자열
    len(not_tab_string)         # 2
    ```
    
    - 세 개의 따옴표(`“””`)를 사용하면 하나의 문자열을 여러 줄로 나눠서 나타낼 수 있음
    - 예외처리: `try, except`
    - 자료구조 `list`
        
        ```python
        # list 예시
        fruits = ['apple', 'banana', 'cherry', 'apple']
        print(fruits)  # ['apple', 'banana', 'cherry', 'apple']
        ```
        
        - 대괄호를 사용해 list의 n번째 값을 불러오거나 설정 가능
        - 대괄호를 사용해서 list를 나누는 것도 가능
        - in 연산자로 list 안에서 항목의 존재 여부 확인 가능
        - unpack도 손쉽게 가능
        - list끼리 더하기도 가능
        
        ```python
        # 1. 대괄호를 사용해 list의 n번째 값을 불러오거나 설정 가능
        fruits = ['apple', 'banana', 'cherry']
        print(fruits[1])  # 'banana'
        fruits[2] = 'orange'
        print(fruits)  # ['apple', 'banana', 'orange']
        print(fruits[-1])  # 'cherry' (마지막 요소)
        
        # 2. 대괄호를 사용해서 list를 나누는 것도 가능
        numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
        sub_numbers = numbers[2:5]  # 인덱스 2부터 4까지
        print(sub_numbers)  # [2, 3, 4]
        
        # 3. in 연산자로 list 안에서 항목의 존재 여부 확인 가능
        colors = ['red', 'green', 'blue']
        print('green' in colors)  # True
        print('yellow' in colors)  # False
        
        # 4. unpack도 손쉽게 가능
        data = [1, 2, 3]
        a, b, c = data
        print(a, b, c)  # 1 2 3
        
        # 5. list 더하기
        x = [1, 2, 3]
        y = x + [4, 5, 6]      # y는 이제 [1, 2, 3, 4, 5, 6]이며 x는 변하지 않음
        
        ```
        
    - 자료구조 `tuple`
        
        ```python
        # tuple 예시
        coordinates = (10.0, 20.0)
        print(coordinates)  # (10.0, 20.0)
        ```
        
        - 변경할 수 없는 list
        - 대괄호 대신 괄호, 혹은 아무런 기호 없이 정의
        - 대괄호를 사용해 list의 n번째 값을 불러오거나 설정 가능
        - 대괄호를 사용해서 list를 나누는 것도 가능
        - in 연산자로 list 안에서 항목의 존재 여부 확인 가능
        - unpack도 손쉽게 가능
        - 다중 할당 지원
    - 자료구조 `dict`
        - key-value 구조, 중복 key 허용
        
        ```python
        empty_dict = {}                         # 가장 파이썬스럽게 dict를 만드는 방법
        empty_dict2 = dict()                    # 덜 파이썬스럽게 dict를 만드는 방법
        grades = { "Joel" : 80, "Tim" : 95 }    # dict 예시
        ```
        
        - 연산자 `in` 사용가능 (`True/False` 반환)
        - `get` 메소드 사용 시, 해당 key가 없어도 기본값 반환
        - 대괄호로 key와 value를 새로 지정 가능
        - `keys(), values(), items()` 메소드로 모든 key/value 등을 한 번에 보기 가능
            
            ![image.png](image%203.png)
            
        - key는 수정할 수 없으며, list를 key로 사용 불가능
    - 자료구조 `defaultdict` (별도 항목 참조)
        - 기본값을 제공하여 키가 존재하지 않을 때 자동으로 초기화된 값 반환
        - 카운팅, 그룹화, 중첩 딕셔너리에 자주 사용
        
        ```python
        from collections import defaultdict
        
        # 단어의 빈도 수 세기
        word_count = defaultdict(int)
        words = ['apple', 'banana', 'apple', 'orange', 'banana', 'apple']
        
        for word in words:
            word_count[word] += 1
        
        print(word_count)  # defaultdict(<class 'int'>, {'apple': 3, 'banana': 2, 'orange': 1})
        
        # 학생의 과목별 점수 저장
        scores = [('Alice', 'Math', 90), ('Bob', 'Math', 85), ('Alice', 'Science', 95), ('Bob', 'Science', 80)]
        subject_scores = defaultdict(list)
        
        for name, subject, score in scores:
            subject_scores[subject].append((name, score))
        
        print(subject_scores)
        # defaultdict(<class 'list'>, {'Math': [('Alice', 90), ('Bob', 85)], 'Science': [('Alice', 95), ('Bob', 80)]})
        
        # 중첩 딕셔너리로 학생의 과목별 점수 저장
        student_scores = defaultdict(lambda: defaultdict(int))
        
        student_scores['Alice']['Math'] = 90
        student_scores['Alice']['Science'] = 95
        student_scores['Bob']['Math'] = 85
        student_scores['Bob']['Science'] = 80
        
        print(student_scores)
        # defaultdict(<function <lambda> at 0x...>, {'Alice': defaultdict(<class 'int'>, {'Math': 90, 'Science': 95}), 'Bob': defaultdict(<class 'int'>, {'Math': 85, 'Science': 80})})
        
        ```
        
    - `Counter`
        - 연속된 값을 defaultdict(int)와 유사한 객체로 변환, key-value의 빈도를 연결
        - 특정 숫자나 단어의 개수 셀 때 유용, 히스토그램 그릴 때 많이 사용함
        - most_common() 메소드로 가장 자주 나오는 항목과 빈도수 출력 가능
        
        ```python
        from collections import Counter
        
        # 단어의 빈도 수 세기
        words = ['apple', 'banana', 'apple', 'orange', 'banana', 'apple']
        word_count = Counter(words)
        
        print(word_count)  # Counter({'apple': 3, 'banana': 2, 'orange': 1})
        
        # 가장 흔한 단어 2개
        print(word_count.most_common(2))  # [('apple', 3), ('banana', 2)]
        
        ```
        
    - 자료구조 `set`
        
        ```python
        # Set 예시
        unique_numbers = {1, 2, 3, 2, 1}
        print(unique_numbers)  # {1, 2, 3}
        ```
        
        - 파이썬의 데이터 구조 중 유일하게 항목의 집합을 나타내는 구조
        - in이 굉장히 빠르게 작동, 중복 제거라는 2가지 장점 존재
    - 조건문 `if ~ elif ~ else`
    - `while`  대신에 `for x in range():` 를 더 많이 사용
        
        ```python
        # while 루프
        print("While Loop:")
        count = 0
        while count < 5:
            print(count)
            count += 1
        
        # for x in range() 루프
        print("Range Loop:")
        for count in range(5):
            print(count)
        ```
        
    - true → `True`, false → `False`, null → `None`
    - `None`은 == 대신 `is` 사용 (x is None)
- **파이썬 문법 심화**
    - 정렬
        - `sort(), sorted()` 메소드
        - 내림차순: `reverse=True`를 인자로 사용
        - key를 사용하면 지정한 함수의 결과값을 기준으로 list 정렬 가능
        
        ```python
        x = [4, 1, 2, 3]
        y = sorted(x)   # y는 [1, 2, 3, 4], 하지만 x는 변하지 않음
        x.sort()        # 이제 x는 [1, 2, 3, 4]
        
        # 절댓값의 내림차순으로 list 정렬
        x = sorted([-4, 1, -2, 3], key=abs, reverse = True)    # 결과는 [-4, 3, -2, 1]
        
        # 빈도의 내림차순으로 단어와 빈도를 정렬
        wc = sorted(word_counts.items(),
                    key=lambda (word, count): count,
                    reverse=True)
        ```
        
    - List Comprehension
        - 기존의 list에서 특정 항목을 선택하거나 변환시킨 결과를 새로운 list에 저장하는 방법
        
        ```python
        even_numbers = [x for x in range(5) if x % 2 == 0]      # [0, 2, 4]
        squares = [x * x for x in range(5)]                     # [0, 1, 4, 9, 16]
        even_squares = [x * x for x in even_numbers]            # [0, 4, 16]
        ```
        
        - dict, set으로 변환 가능
        
        ```python
        square_dict = { x : x * x for x in range(5) }       # { 0:0, 1:1, 2:4, 3:9, 4:16 }
        square_set = { x * x for x in [1, -1] }             # { 1 }
        ```
        
        - list에서 불필요한 값은 밑줄로 표기
        
        ```python
        zeroes = [0 for _ in even_numbers]      # even_numbers와 동일한 길이
        ```
        
        - for 여러개 포함 가능
    - Generator와 iterator
        - Generator (생성자): 주로 for문을 통해서 반복할 수 있으며, generator의 각 항목은 필요한 순간에 그때그때 생성됨
        - 파이썬 2.대에서는 함수와 yield를 활용하면 되고, xrange로도 구현되어 있음
        
        ```python
        def lazy_range(n):
            """range와 똑같은 기능을 하는 generator"""
            i = 0
            while i < n:
                yield i
                i += 1
        ```
        
        - 파이썬 3에서는 range 자체가 generator로 만들어져, 무한한 수열도 메모리의 제약을 받지 않고 구현할 수 있다고 함
        - 괄호 안에 for문을 추가하는 방법으로도 generator를 만들 수 있다
        
        ```python
        lazy_evens_below_20 = (i for i in range(20) if i % 2 == 0)
        ```
        
        - 제너레이터는 값을 필요할 때마다 동적으로 생성하고, 생성된 값은 소모되기 때문에, 한 번 `for` 루프 등으로 순회하면 그 이후에는 데이터가 더 이상 남아있지 않음
        
        ```python
        def simple_generator():
            yield 1
            yield 2
            yield 3
        
        gen = simple_generator()
        
        # 첫 번째 반복
        for value in gen:
            print(value)  # 1, 2, 3 출력
        
        # 두 번째 반복 시도
        for value in gen:
            print(value)  # 아무것도 출력되지 않음
        ```
        
        - 파이썬 2에서는 `items()`가 리스트, `iteritems()`가 제너레이터를 반환하지만, 파이썬 3에서는 items가 제네레이터와 유사하게 동작하게 바뀌어 `iteritems()`가 삭제됨
    - 난수 생성
        - 난수 (random number)는 random 모듈로 생성
        
        ```python
        import random
        
        four_uniform_randoms = [random.random() for _ in range(4)]
        
        #   [0.844218515250481,             # random.random()은
        #   0.7579544029403025,             # 0과 1 사이의 난수를 생성
        #   0.420571580830845,              # 앞으로 가장 자주 사용할
        #   0.25891675029296335]            # 함수이다
        ```
        
        - `random.seed()` 메소드를 통해 매번 고정된 난수 생성 가능
        - 인자가 1개 혹은 2개인 `random.randrange()` 메소드를 사용하면 range()에 해당하는 구간 안에서 난수 생성 가능
        
        ```python
        import random
        
        random.randrange(10)            # range(10) = [0, 1, ..., 9]에서 난수 생성
        random.randrange(3, 6)          # range(3, 6) = [3, 4, 5]에서 난수 생성
        ```
        
        - `random.shuffle()`은 list의 항목을 임의 순서로 재정렬
        
        ```python
        import random
        
        up_to_ten = list(range(10))  # 먼저 range 객체를 리스트로 변환
        random.shuffle(up_to_ten)  # 리스트를 무작위로 섞음
        print(up_to_ten)  # 무작위 순서로 출력됨
        ```
        
        - `random.choice()` → list에서 임의의 항목을 하나 선택
        - `random.sample()` → list에서 중복이 허용되지 않는 표본 list 생성
    - 정규표현식
        - 매우 유용하지만 상당히 복잡해서 하나씩 추가될 예정, 책에서 일단 예제만 하나 줌
        
        ```python
        import re
        
        print(all([                                 # 모두 True
            not re.match("a", "cat"),               # 'cat'은 'a'로 시작하지 않기 때문에 True
            re.search("a", "cat"),                  # 'cat' 안에 'a'가 있으므로 True
            not re.search("c", "dog"),              # 'dog' 안에 'c'가 없으므로 True
            3 == len(re.split("[ab]", "carbs")),    # 'carbs'를 'a' 또는 'b'로 분리하면 길이가 3
        
            "R-D-" == re.sub("[0-9]", "-", "R2D2")  # 숫자를 '-'로 대체하여 "R-D-"가 되는지 확인
        ]))
        ```
        
    - 객체 지향 프로그래밍
        - 파이썬도 클래스를 사용해서 데이터와 관련 함수를 묶는 것이 가능
        
        ```python
        # 클래스의 이름은 관습에 따라 파스칼케이스로 표기
        class Set:
            # 이제 모든 멤버 함수들을 정의
            # 모든 멤버 함수의 첫 번째 인자는 "self"이다 (관습 중 하나)
            # "self"란 현재 사용되고 있는 Set 객체를 의미한다
        
            def __init__(self, values = None):
                """이것은 constructor(생성자)이다
                새로운 Set을 만들면 호출된다
                다음과 같이 사용할 수 있다.
                s1 = Set()              # 비어 있는 Set
                s2 = Set([1, 2, 3, 4])  # 초깃값이 주어진 Set"""
        
                self.dict = {}              # 모든 Set의 인스턴스는 자체적으로 dict를 유지한다.
                                            # 이 dict를 통해 항목의 존재 여부를 확인할 것이다.
                if values is not None:
                    for value in values:
                        self.add(value)
        
            def __repr__(self):
                """파이썬 프롬프트에서 이 함수를 입력하거나 str()으로 보내 주면
                Set 객체를 문자열로 표현해 줌"""
                return "Set: " + str(list(self.dict.keys()))
            
            # self.dict에서 항목과 True를 각각 key와 value로 사용해서
            # Set 안에 존재하는 항목을 표현
            def add(self, value):
                self.dict[value] = True
        
            # 만약 항목이 dict의 key라면 항목은 Set 안에 존재함
            def contains(self, value):
                return value in self.dict
            
            def remove(self, value):
                del self.dict[value]
        ```
        
        - 
    - 함수형 도구
        - 한 함수의 특정 부분을 사용해서 새로운 함수를 만드는 것을 partial function application 또는 currying이라고 함
        
        ```python
        from functools import partial
        
        def exp(base, power):
            return base ** power
        
        def two_to_the(power):
            return exp(2, power)
        
        two_to_the = partial(exp, 2)    # 이제 입력변수가 하나인 함수로 변환되었다
        print(two_to_the(3))            # 8
        ```
        
        - 인자의 이름을 명시해주면 뒤에 나오는 인자에도 partial 적용 가능
        - list comprehension의 대안으로 map, reduce, filter를 사용하기도 함
        - map
        
        ```python
        from functools import partial
        
        def double(x):
            return 2 * x
        
        xs = [1, 2, 3, 4]
        twice_xs = [double(x) for x in xs]      # [2, 4, 6, 8]
        twice_xs = map(double, xs)              # 위의 결과와 동일
        list_doubler = partial(map, double)     # list의 값을 두 배로 만들어주는 함수
        twice_xs = list_doubler(xs)             # 결과는 여전히 [2, 4, 6, 8]
        
        def multiply(x, y):
            return x * y
        
        products = map(multiply, [1, 2], [4, 5])        # [1 * 4, 2 * 5] = [4, 10]
        ```
        
        - filter
        
        ```python
        def is_even(x):
            """x가 짝수면 True, 홀수면 False"""
            return x % 2 == 0
        
        x_evens = [x for x in xs if is_even(x)]     # [2, 4]
        x_evens = filter(is_even, xs)               # 위의 결과와 동일
        list_evener = partial(filter, is_even)      # list를 필터링해 주는 함수
        x_evens = list_evener(xs)                   # 결과는 여전히 [2, 4]
        ```
        
        - reduce
        
        ```python
        x_product = reduce(multiply, xs)            # = 1 * 2 * 3 * 4 = 24
        list_product = partial(reduce, multiply)    # list에 reduce를 적용하는 함수
        x_product = list_product(xs)                # 결과는 여전히 24
        ```
        
    - enumerate
        - list를 반복하면서 list의 항목과 인덱스가 모두 필요한 경우가 종종 있음
        - enumerate: 리스트나 튜플과 같은 iterable의 각 요소에 인덱스를 붙여주는 유용한 함수
        - enumerate를 사용하면, 일일이 인덱스를 붙이지 않고도 아래처럼 가능
        
        ```python
        # 이 방법은 파이썬스럽지 않다
        for i in range(len(documents)):
            document = documents[i]
            do_something(i, document)
        
        # 이 방법 또한 파이썬스럽지 않다
        i = 0
        for document in documents:
            do_something(i, document)
            i += 1
        
        # enumerate 활용하기
        for i, document in enumerate(documents):
            do_something(i, document)
        
        # 인덱스만 필요할 경우
        for i in range(len(documents)): do_something(i)     # 파이썬스럽지 않다
        for i, _ in enumerate(documents): do_something(i)   # 파이썬스럽다
        ```
        
    - zip과 argument unpacking
        - zip: 여러 개의 list를 서로 상응하는 항목의 tuple로 구성된 list로 변환
        
        ```python
        list1 = ['a', 'b', 'c']
        list2 = [1, 2, 3]
        zip(list1, list2)           # [('a', 1), ('b', 2), ('c', 3)]
        ```
        
        - 별표(*)를 활용하여 다시 unpacking 하는 것도 가능
        
        ```python
        pairs = [('a', 1), ('b', 2), ('c', 3)]
        letters, numbers = zip(*pairs)
        """zip(*pairs) == zip(('a', 1), ('b', 2), ('c', 3))
        반환값: [('a', 'b', 'c'), ('1', '2', '3')]"""
        ```
        
        - 
    - args와 kwargs

1. **데이터 과학 관련**
- **데이터 시각화**
    - 목적: **데이터 탐색, 데이터 전달**
    - matplotlib(간단한 막대 그래프, 선 그래프, 산점도 그릴 때 유용)
    
    ```python
    from matplotlib import pyplot as plt
    years = [1950, 1960, 1970, 1980, 1990, 2000, 2010]
    gdp = [300.2, 543.3, 1075.9, 2862.5, 5979.6, 10289.7, 14958.3]
    
    # x축에 연도, y축에 GDP가 있는 선 그래프를 만들자
    plt.plot(years, gdp, color='green', marker='o', linestyle='solid')
    
    # 제목을 더하자
    plt.title("Nominal GDP")
    
    # y축에 레이블을 추가하자
    plt.ylabel("Billions of $")
    plt.show()
    ```
    
    ![Figure_1.png](Figure_1.png)
    
    - **막대그래프**
        - **이산적인 항목들에 대한 변화**를 보여줄 때 유용함
        - 아래는 영화 아카데미 시상식 수상 갯수 정리
        - 이 뒤의 코드에선 수정했지만, 막대가 가운데로 올 수 있도록 수정하는 건 최신 버전에선 알아서 처리되도록 바뀐 것 같음(처리를 해주니 오히려 밀려버리는 모습)
        
        ```python
        from matplotlib import pyplot as plt
        
        movies = ["Annie Hall", "Ben-Hur", "Casablanca", "Gandhi", "West Side Story"]
        num_oscars = [5, 11, 3, 8, 10]
        
        # 막대 너비의 기본값이 0.8이므로
        # 막대가 가운데로 올 수 있도록 왼쪽 좌표에 0.1씩 더해 주자
        xs = [i + 0.1 for i, _ in enumerate(movies)]
        
        # 왼편으로부터 x축의 위치가 xs이고 높이가 num_oscars인 막대를 그리자
        plt.bar(xs, num_oscars)
        plt.ylabel("# of Academy Awards")
        plt.title("My Favorite Movies")
        
        # 막대의 가운데에 오도록 영화 제목 레이블을 달자
        plt.xticks([i + 0.5 for i, _ in enumerate(movies)], movies)
        plt.show()
        ```
        
        ![Figure_2.png](Figure_2.png)
        
        - 막대 그래프를 이용해 히스토그램도 작성 가능
        
        ```python
        from collections import Counter
        from matplotlib import pyplot as plt
        
        grades = [83, 95, 91, 87, 70, 0, 85, 82, 100, 67, 73, 77, 0]
        decile = lambda grade: grade // 10 * 10
        histogram = Counter(decile(grade) for grade in grades)
        
        # keys()와 values()를 리스트로 변환
        x_values = list(histogram.keys())
        y_values = list(histogram.values())
        
        plt.bar( x_values,
                 y_values,                  # 각 막대의 높이를 정해주고
                 width=8)                   # 너비는 8로 하자
        
        plt.axis([-5, 105, 0, 5])           # x축은 -5부터 105
                                            # y축은 0부터 5
        
        plt.xticks([10 * i for i in range(11)])  # x축의 레이블은 0, 10, ..., 100
        plt.xlabel("Decile")
        plt.ylabel("# of Students")
        plt.title("Distribution of Exam 1 Grades")
        plt.show()
        ```
        
        ![[plt.bar](http://plt.bar)() 함수의 작동방식 변경 때문인지 책 예제와는 다르게 plt.bar 함수에서 [x - 4 for x in histogram.keys()를 안해야지 제대로 x축 위치를 잡을 수 있었음](Figure_4.png)
        
        [plt.bar](http://plt.bar)() 함수의 작동방식 변경 때문인지 책 예제와는 다르게 plt.bar 함수에서 [x - 4 for x in histogram.keys()를 안해야지 제대로 x축 위치를 잡을 수 있었음
        
        ```python
        mentions = [500, 505]
        years = [2013, 2014]
        
        plt.bar(years, mentions, 0.8)
        plt.xticks(years)
        plt.ylabel("# of times I heard someone say 'data science'")
        
        # 이렇게 하지 않으면 matplotlib이 x축에 0, 1 레이블을 달고
        # 주변부 어딘가에 +2.013e3 라고 표기해둘 것이다.
        plt.ticklabel_format(useOffset=False)
        
        # 오해를 불러일으키는 y축은 500 이상의 부분만 보여줄 것이다
        plt.axis([2012.5, 2014.5, 499, 506])
        plt.title("Look at the 'Huge' Increase!")
        plt.show()
        
        # y축을 적합하게 변경
        plt.axis([2012.5, 2014.5, 0, 550])
        plt.title("Not So Huge Anymore")
        plt.show()
        ```
        
        ![Figure_5.png](Figure_5.png)
        
        ![Figure_6.png](Figure_6.png)
        
    - 선 그래프
        - `plt.plot()` 을 이용하면 선 그래프 그리기 가능
        - 어떤 경향을 보여줄 때 유용
        
        ```python
        from matplotlib import pyplot as plt
        
        variance = [1, 2, 4, 8, 16, 32, 64, 128, 256]
        bias_squared = [256, 128, 64, 32, 16, 8, 4, 2, 1]
        total_error = [x + y for x, y in zip(variance, bias_squared)]
        xs = [i for i, _ in enumerate(variance)]
        
        # 한 차트에 여러 개의 series를 그리기 위해
        # plt.plot을 여러 번 호출할 수 있다
        plt.plot(xs, variance, 'g-', label='variance')      # 초록색 실선
        plt.plot(xs, bias_squared, 'r-.', label='bias^2')   # 붉은색 점선
        plt.plot(xs, total_error, 'b:', label='total error') # 파란색 점선
        
        # 각 series에 label을 미리 달아놨기 때문에
        # 범례(legend)를 어렵지 않게 그릴 수 있다
        # 여기서 loc=9는 "top center(위쪽 중앙)"을 의미한다
        plt.legend(loc=9)
        plt.xlabel("model complexity")
        plt.title("The Bias-Variance Tradeoff")
        plt.show()
        ```
        
        ![Figure_7.png](Figure_7.png)
        
    - 산점도(scatterplots)
        - 두 변수 간의 연관 관계를 보여주고 싶을 때 유용
        - 아래는 각 사용자의 친구 수와 그들이 매일 사이트에서 체류하는 시간 사이의 연관성
        
        ```python
        from matplotlib import pyplot as plt
        
        friends = [ 70, 65, 72, 63, 71, 64, 60, 64, 67]
        minutes = [ 175, 170, 205, 120, 220, 130, 105, 145, 190]
        labels = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i']
        
        plt.scatter(friends, minutes)
        
        # 각 포인트에 레이블을 달자
        for label, friend_count, minute_count in zip(labels, friends, minutes):
            plt.annotate(label,
                         xy=(friend_count, minute_count),       # label을 데이터 포인트 근처에 두되
                         xytext=(5, -5),                        # 약간 떨어져 있게 하자
                         textcoords='offset points')
            
        plt.title("Daily Minutes vs. Number of Friends")
        plt.xlabel("# of friends")
        plt.ylabel("daily minutes spent on the site")
        plt.show()
        ```
        
        ![Figure_8.png](Figure_8.png)
        
        - 변수들끼리 비교할 때, matplotlib가 자동으로 축의 범위를 설정하게 하면 공정한 비교를 못하게 될 수 있음
        - 따라서 plt.axis(”equal”)을 추가해줄 필요가 있다
        
        ```python
        from collections import Counter
        from matplotlib import pyplot as plt
        
        test_1_grades = [ 99, 90, 85, 97, 80 ]
        test_2_grades = [ 100, 85, 60, 90, 70 ]
        
        plt.scatter(test_1_grades, test_2_grades)
        plt.title("Axes Aren't Comparable")
        plt.xlabel("test 1 grade")
        plt.ylabel("test 2 grade")
        plt.axis("equal")
        plt.show()
        ```
        
        ![plt.axis("equal") 미사용시](Figure_9.png)
        
        plt.axis("equal") 미사용시
        
        ![plt.axis("equal") 사용시](Figure_10.png)
        
        plt.axis("equal") 사용시
        
    - 이후 더 공부하려면 이하의 라이브러리를 활용해보길 추천
        - seaborn
        - D3.js
        - Bokeh
        - ggplot
        
- **선형대수(linear algebra)**
    - 선형대수: 데이터 분석에 필요한 각종 계산을 돕는 학문
    - 데이터 분석을 하려면 수많은 숫자로 이루어진 데이터를 다루어야 하는데, 선형대수를 사용하면 복잡한 계산 과정을 간단한 수식으로 서술 가능함
    - 데이터는 개수나 형태에 따라 크게 스칼라(scalar), 벡터(vector), 행렬(matrix), 텐서(tensor) 유형으로 나뉨
    - 텐서 > 행렬 > 벡터 > 스칼라
    - 벡터
        - 간단히 표현하면, “크기와 방향을 가진 화살표”
        - 다차원 데이터를 표현하는 데 적합. 각 데이터 포인트를 n차원 공간의 점으로 나타냄
        - 데이터 과학에선 벡터끼리 더하거나 상수와 곱해지면 새로운 벡터를 생성하는 개념적인 도구라고 이해하면 편함
        - 머신러닝에서는 각 데이터 샘플을 특징 벡터로 표현하여 모델에 입력하여, 특정 특징(예: 나이, 소득, 키 등)을 나타냄
        - 벡터 더하기: 두 개의 벡터를 더해서 하나의 벡터로 만들 수 있다. 예를 들어, 물체에 두 방향에서 힘이 가해질 때, 두 힘을 더해서 전체 힘의 방향과 크기를 계산 가능
        - 데이터 과학에선 각 벡터 상에서 같은 위치에 있는 성분끼리 더하는 것
        
        ```python
        def vector_add(v, w):
            """각 성분끼리 더한다"""
            return [v_i + w_i
                    for v_i, w_i in zip(v, w)]
                    
        # reduce를 사용하여 벡터의 합을 계산
        def vector_sum(vectors):
        		return reduce(vector_add, vectors)
        		
        # partial을 사용하여 vector_sum을 더 간단하게 표현
        vector_sum = partial(reduce, vector_add)
        ```
        
        - 벡터의 내적: 벡터가 어느 방향으로 얼마나 겹쳐져 있는가를 나타냄
        - 좀 더 자세히 설명하자면, 벡타 1이 벡터 2 방향으로 얼마나 멀리 뻗어져 나가는지를 나타낸다. 다른 관점에서 보자면 내적은 벡터 1이 벡터 2로 투영된 길이를 나타낸다.
        - 내적의 개념을 사용하면, 각 성분의 제곱 값의 합을 쉽게 구할 수 있음
        
        ```python
        def dot(v, w):
            """v_1 * w_1 + ... + v_n + w_n"""
            return sum(v_i * w_i
                       for v_i, w_i in zip(v, w))
        
        def sum_of_squares(v):
            """v_1 * v_1 + ... + v_n * v_n"""
            return dot(v, v)
        ```
        
        - 제곱 값의 합을 이용하면 벡터의 크기도 계산 가능함
        
        ```python
        def magnitude(v):
            return math.sqrt(sum_of_squares(v))         # math.sqrt는 제곱근을 계산해주는 함수
        ```
        
        - 이를 응용해 두 벡터 간의 거리도 계산 및 정의가 가능하다
        
        ```python
        def vector_subtract(v, w):
            """각 성분끼리 뺀다"""
            return [v_i - w_i
                    for v_i, w_i in zip(v, w)]
        
        def squared_distance(v, w):
            """(v_1 - w_1) ** 2 + ... + (v_n - w_n) ** 2"""
            return sum_of_squares(vector_subtract(v, w))
        
        def distance(v, w):
            return math.sqrt(squared_distance(v, w))
        
        # magnitude 메소드로 더욱 깔끔하게 정리
        def distance(v, w):
            return magnitude(vector_subtract(v, w))
        ```
        
        - 벡터를 list로 표현하는 건 원리 설명엔 용이하지만 성능적으론 굉장히 비효율적
        - 따라서 실제 코딩에선 NumPy 라이브러리를 사용할 것
        
    - 행렬
        - 2차원으로 구성된 숫자의 집합 (list의 list)
        - 행렬 A → len(A)개의 행, len(A[0])의 열로 구성
        - A[i] → i번째 행
        
        ```python
        def make_matrix(num_rows, num_cols, entry_fn):
            """(i, j)번째 원소가 entry_fn(i, j)인
            num_rows x num_cols list를 반환"""
            return [[entry_fn(i, j)                     # i가 주어졌을 때, list를 생성한다
                     for j in range(num_cols)]          # [entry_fn(i, 0), ... ]
                     for i in range(num_rows)]          # 각 i에 대해 하나의 list를 생성한다
        
        def is_diagonal(i, j):
            """대각선의 원소는 1, 나머지 원소는 0"""
            return 1 if i == j else 0
        
        identity_matrix = make_matrix(5, 5, is_diagonal)
        print(identity_matrix)
        
        # [[1, 0, 0, 0, 0]],
        # [[0, 1, 0, 0, 0]],
        # [[0, 0, 1, 0, 0]],
        # [[0, 0, 0, 1, 0]],
        # [[0, 0, 0, 0, 1]]
        ```
        
        - 행렬이 중요한 이유
            - 여러 벡터로 구성된 데이터셋을 행렬로 표현 가능
            - k차원의 벡터를 n차원 벡터로 변환해주는 선형함수를 n x k 행렬로 표현 가능
            - 행렬로 이진관계를 표현 가능
            
            ```python
                   # 사용자 0  1  2  3  4  5  6  7  8  9
                   #
            friendships = [[0, 1, 1, 0, 0, 0, 0, 0, 0, 0],      # 사용자0
                           [1, 0, 1, 1, 0, 0, 0, 0, 0, 0],      # 사용자1
                           [1, 1, 0, 1, 0, 0, 0, 0, 0, 0],      # 사용자2
                           [0, 1, 1, 1, 0, 1, 1, 1, 1, 0],      # 사용자3
                           ...,
                           [0, 1, 0, 1, 0, 0, 1, 1, 1, 0]       # 사용자9
                          ]
            
            friendships[0][2] == 1      # 참, 사용자 0과 2는 친구이다
            friendships[0][8] == 0      # 거짓, 사용자 0과 8은 친구가 아니다
            
            friends_of_five = [i
            									 for i, is_friend in enumerate(friendships[5])
            									 if is_friend]
            ```
            
- **통계**
    - 통계는 데이터를 이해하는 바탕이 되는 수리적 비법
    - 중심 경향성: 데이터의 중심이 어디있는지를 나타내는 지표
    - 중심 경향성은 대부분의 경우, 데이터의 값을 데이터 포인트의 개수로 나눈 평균을 사용
    
    ```python
    def mean(x):
        return sum(x) / len(x)
    ```
    
    - 가끔은 중앙값도 필요함
    
    ```python
    def median(v):
        """v의 중앙값을 계산"""
        n = len(v)
        sorted_v = sorted(v)
        midpoint = n / 2
    
        if n % 2 == 1:
            # 데이터 포인트의 개수가 홀수면 중앙값을 반환
            return sorted_v[midpoint]
        else:
            # 데이터 포인트의 개수가 짝수면 두 중앙값의 평균을 반환
            lo = midpoint - 1
            hi = midpoint
            return (sorted_v[lo] + sorted_v[hi]) / 2
    ```
    
    - 평균과 중앙값 비교
        - 평균: 계산이 간편, 데이터의 변화에 따른 값의 변화가 부드러움, 이상치에 민감함
        - (마이클 조던이 지리학과 졸업 → 해당 대학 지리학과 졸업생 초봉이 제일 높다고 조사됨)
        - 중앙값: 계산을 위해선 데이터 정렬이 필요, 주어진 데이터의 변화에 둔감
    - 흔치는 않지만 최빈값을 살펴보는 경우도 있음
    
    ```python
    from collections import Counter
    
    def mode(x):
        """최빈값이 하나보다 많다면 list를 반환"""
        counts = Counter(x)
        max_count = max(counts.values())
        return [x_i for x_i, count in counts.items()
                if count == max_count]
    ```
    
    - 산포도(dispersion):
        - 데이터가 얼마나 퍼져 있는지를 나타냄
        - 일반적으로 0과 근접한 값이면 거의 퍼져있지 않다는 의미, 큰 값이면 매우 퍼져있다는 의미
        
        ```python
        # 가장 큰 값 - 작은 값의 차이를 나타내는 범위는 산포도를 나타내는 가장 간단한 통계치다
        # 데이터 전체에 의존하지 않음 (중앙값과 비슷함)
        def data_range(x):
            return max(x) - min(x)
        ```
        
        - 분산(variance)
        
        ```python
        # 분산은 산포도를 측정하는 약간 더 복잡한 개념
        def de_mean(x):
            """x의 모든 데이터 포인트에서 평균을 뺌(평균을 0으로 만들기 위해)"""
            x_bar = mean(x)
            return [x_i - x_bar for x_i in x]
        
        def variance(x):
            """x에 두 개 이상의 데이터 포인트가 존재한다고 가정"""
            n = len(x)
            deviations = de_mean(x)
            return sum_of_squares(deviations) / (n - 1)
         
         """
         식을 살펴보면 편차의 제곱의 평균을 계산하는 데 n 대신에 n - 1로 나누는 것을
         확인할 수 있다. 이는 편차의 제곱합을 n으로 나누면 bias 때문에 모분산에 대한
         추정값이 실제 모분산보다 작게 계산되는 것을 보정해주기 위함이다.
         """
        ```
        
        - 분산 대신에 원래 단위와 같은 단위를 가지는 표준편차를 이용할 때가 많음
        
        ```python
        # 분산의 단위는 기존 단위의 제곱이므로,
        # 분산 대신에 원래 단위와 같은 단위를 가지는 표준편차를 이용할 때가 많다
        import math
        
        def standard_deviation(x):
            return math.sqrt(variance(x))
        ```
        
        -